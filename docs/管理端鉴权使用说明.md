# 管理端鉴权系统使用说明

## 一、功能概述

本系统实现了完整的管理端鉴权功能，包括：
- 管理员账号密码登录
- JWT Token 认证
- 基于注解的权限验证
- 管理员与普通用户的隔离

## 二、数据库初始化

### 1. 执行 SQL 脚本

运行 `sql/admin_user.sql` 创建管理员用户表，并插入默认超级管理员：

- 默认账号：`admin`
- 默认密码：`admin123`

### 2. 表结构说明

`admin_user` 表包含以下字段：
- `id`: 管理员ID
- `username`: 登录账号（唯一）
- `password`: BCrypt加密的密码
- `real_name`: 真实姓名
- `phone`: 手机号
- `email`: 邮箱
- `avatar`: 头像URL
- `role_type`: 角色类型（0-超级管理员，1-普通管理员，预留扩展）
- `status`: 状态（0-禁用，1-启用）
- `last_login_time`: 最后登录时间
- `last_login_ip`: 最后登录IP

## 三、API 接口

### 1. 管理员登录
```
POST /admin/login
```

**请求体：**
```json
{
  "username": "admin",
  "password": "admin123"
}
```

**响应：**
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "accessToken": "eyJhbGc...",
    "refreshToken": "eyJhbGc...",
    "adminId": 1,
    "username": "admin",
    "realName": "超级管理员"
  }
}
```

### 2. 管理员登出
```
POST /admin/logout
```

**请求头：**
```
Authorization: Bearer {accessToken}
```

### 3. 获取当前管理员信息
```
GET /admin/info
```

**请求头：**
```
Authorization: Bearer {accessToken}
```

**响应：**
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "id": 1,
    "username": "admin",
    "realName": "超级管理员",
    "phone": null,
    "email": null,
    "avatar": null,
    "roleType": 0,
    "status": 1,
    "lastLoginTime": "2025-10-11 10:30:00",
    "lastLoginIp": "127.0.0.1"
  }
}
```

## 四、如何使用权限验证

### 1. 在 Controller 方法上添加注解

```java
@PostMapping("/admin/order/cancel")
@RequireAdmin  // 添加此注解，表示需要管理员权限
@Operation(summary = "取消订单")
public ResponseResult<Void> cancelOrder(@RequestBody Long orderId) {
    // 业务逻辑
    return ResponseResult.success();
}
```

### 2. 在整个 Controller 类上添加注解

```java
@RestController
@RequestMapping("/admin/user")
@RequireAdmin  // 整个Controller的所有方法都需要管理员权限
public class AdminUserController {
    // 所有方法自动继承权限要求
}
```

### 3. 预留的角色细化权限（未来扩展）

```java
// 未来可以这样使用
@RequireAdmin(roles = {0})  // 仅超级管理员可访问
@RequireAdmin(roles = {0, 1})  // 超级管理员和普通管理员都可访问
```

## 五、工作原理

### 1. 认证流程

```
1. 管理员提交账号密码
   ↓
2. 系统验证账号密码（BCrypt）
   ↓
3. 生成 JWT Token（包含 userType=ADMIN）
   ↓
4. 将 RefreshToken 存入 Redis (admin:login:{adminId})
   ↓
5. 返回 AccessToken 和 RefreshToken
```

### 2. 权限验证流程

```
1. 请求携带 Authorization Header
   ↓
2. JwtInterceptor 拦截验证 Token
   ↓
3. 提取 userType, userId, username 到 ThreadLocal
   ↓
4. AdminPermissionAspect 检查 userType 是否为 ADMIN
   ↓
5. 验证通过，执行业务方法
```

### 3. 用户类型隔离

- **普通用户 Token**: `userType = USER`, Redis Key: `user:login:{userId}`
- **管理员 Token**: `userType = ADMIN`, Redis Key: `admin:login:{adminId}`

两种用户完全隔离，互不影响。

## 六、核心类说明

### 1. 注解类
- `@RequireAdmin`: 标记需要管理员权限的接口

### 2. 切面类
- `AdminPermissionAspect`: 权限验证切面，在方法执行前验证管理员身份

### 3. 拦截器
- `JwtInterceptor`: JWT Token 验证，支持普通用户和管理员
- `WebMvcConfig`: 配置拦截器和放行路径

### 4. Service 层
- `IAdminAuthService`: 管理员认证服务接口
- `AdminAuthServiceImpl`: 管理员认证服务实现

### 5. 工具类
- `JwtUtil`: JWT Token 生成和解析
- `PasswordUtils`: BCrypt 密码加密和验证
- `IpUtils`: 获取客户端IP地址

## 七、代码规范

### 1. 常量使用规范

**错误信息常量（ErrorConst）**：
所有业务异常的错误信息统一放在 `ErrorConst` 类中：
```java
// 在 ErrorConst 中定义
public static final String ADMIN_LOGIN_ERROR = "账号或密码错误";

// 在代码中使用
throw new AdminLoginException(ErrorConst.ADMIN_LOGIN_ERROR);
```

**参数校验常量（ValidationConstants）**：
所有 DTO 参数校验的错误提示统一放在 `ValidationConstants` 类中：
```java
// 在 ValidationConstants 中定义
public static final String ADMIN_USERNAME_NOT_NULL = "用户名不能为空";

// 在 DTO 中使用
@NotBlank(message = ValidationConstants.ADMIN_USERNAME_NOT_NULL)
private String username;
```

## 八、配置说明

### 1. 放行路径（WebMvcConfig）

以下路径不需要 Token 验证：
- `/user/wx/login` - 小程序登录
- `/admin/login` - 管理员登录
- `/swagger-ui/**` - Swagger 文档
- `/v3/api-docs/**` - API 文档
- `/doc.html` - Knife4j 文档

### 2. Redis Key 管理

在 `RedisKeyManage` 枚举中新增：
```java
ADMIN_LOGIN("admin:login:%s","管理员id" ,"value为refreshToken")
```

### 3. JWT Token 配置

Token 中包含的字段：
- `userId`: 用户/管理员ID
- `status`: 状态
- `userType`: USER 或 ADMIN
- `username`: 管理员登录名（仅管理员有）

## 九、注意事项

### 1. Maven 依赖

确保 `pom.xml` 中已添加：
```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
</dependency>
```

### 2. 首次使用

运行项目后，使用默认管理员账号登录：
- 账号：`admin`
- 密码：`admin123`

登录成功后建议立即修改密码（需实现修改密码接口）。

### 3. 密码加密

新增管理员时，必须使用 `PasswordUtils.encode()` 加密密码：
```java
String encodedPassword = PasswordUtils.encode("rawPassword");
adminUser.setPassword(encodedPassword);
```

### 4. 获取当前管理员信息

在 Service 或 Controller 中，可以从 ThreadLocal 获取：
```java
Long adminId = Long.valueOf(UserContext.get("userId"));
String username = UserContext.get("username");
String userType = UserContext.get("userType");  // "ADMIN"
```

## 十、扩展指南

### 1. 添加细化权限

未来如需实现基于角色的细化权限：

1. 在 `AdminPermissionAspect` 中解析 `@RequireAdmin` 的 `roles` 属性
2. 从 Token 或数据库获取管理员的 `roleType`
3. 验证 `roleType` 是否在允许的 `roles` 数组中

### 2. 添加管理员管理功能

可以创建 `AdminUserController` 实现：
- 管理员列表查询
- 新增管理员
- 修改管理员信息
- 删除/禁用管理员
- 重置管理员密码

## 十一、常见问题

### 1. Token 过期怎么办？

系统支持 Token 自动续签：
- 当 AccessToken 过期时，拦截器会检查 Redis 中的 RefreshToken
- 如果 RefreshToken 有效，自动生成新的 AccessToken
- 新 Token 会通过响应头 `New-Access-Token` 返回

### 2. 如何强制管理员下线？

删除 Redis 中对应的 Key：
```java
redisCache.del(RedisKeyBuild.createKey(RedisKeyManage.ADMIN_LOGIN, adminId));
```

### 3. 如何区分管理员和普通用户？

在 Controller 或 Service 中：
```java
String userType = UserContext.get("userType");
if ("ADMIN".equals(userType)) {
    // 管理员逻辑
} else {
    // 普通用户逻辑
}
```

## 十二、安全建议

1. **生产环境必须修改默认密码**
2. **定期更新 JWT Secret Key**（配置在 `application.yml` 中）
3. **设置合理的 Token 过期时间**
4. **生产环境启用 HTTPS**
5. **记录管理员操作日志**（操作日志功能将在下一阶段实现）
6. **限制登录失败次数**（可添加 Redis 计数器实现）
7. **敏感操作需要二次验证**（如删除数据）

---

**创建日期**: 2025-10-11  
**版本**: v1.0  
**作者**: haibara

